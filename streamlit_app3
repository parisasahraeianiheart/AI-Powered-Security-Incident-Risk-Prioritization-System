"""
Streamlit SOC Triage Dashboard (Agent Output Viewer)

What it does:
- Reads a triage JSON output generated by your SOC agent (recommended: triage_output.json)
- Displays KPIs, alert queue, alert details, and risk distribution
- Adds a button to download your final report PDF (if present)

Run:
  streamlit run streamlit_soc_triage_dashboard.py

Expected JSON structure (minimum):
{
  "model": "xgboost",
  "mode": "min_cost",
  "cost_model": {"C_FP": 1.0, "C_FN": 20.0},
  "threshold": 0.064,
  "baseline_cost": 37724,
  "optimized_cost": 15634,
  "cost_reduction": 0.5856,
  "metrics_at_threshold": {"precision": 0.744, "recall": 1.0, "fpr": 0.423, "tp":..., "fp":..., "fn":..., "tn":...},
  "top_alerts": [
    {"idx": 13182, "p": 1.0, "decision": "ESCALATE",
     "explanation": "...", "suggested_actions": ["...", "..."] }
  ],
  "llm_brief": "optional long text"
}
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Optional

import pandas as pd
import streamlit as st


# -----------------------------
# Config
# -----------------------------
ROOT = Path(__file__).resolve().parent

DEFAULT_TRIAGE_JSON = ROOT / "triage_output.json"   # <— recommend your agent writes this
DEFAULT_REPORT_PDF = ROOT / "SOC_Triage_Project_Report_Formatted.pdf"  # <— rename if needed


# -----------------------------
# Helpers
# -----------------------------
def load_json(path: Path) -> Optional[Dict[str, Any]]:
    if not path.exists():
        return None
    try:
        return json.loads(path.read_text())
    except Exception:
        return None


def to_alert_df(triage: Dict[str, Any]) -> pd.DataFrame:
    alerts = triage.get("top_alerts") or []
    df = pd.DataFrame(alerts)
    if df.empty:
        return df

    # Normalize expected columns
    if "p" in df.columns:
        df["p"] = pd.to_numeric(df["p"], errors="coerce")

    if "idx" in df.columns:
        df["idx"] = pd.to_numeric(df["idx"], errors="coerce").astype("Int64")

    if "decision" not in df.columns:
        df["decision"] = ""

    # Helpful derived fields
    df["risk_bucket"] = pd.cut(
        df["p"].fillna(0.0),
        bins=[-1, 0.2, 0.5, 0.8, 1.0000001],
        labels=["Low", "Medium", "High", "Critical"],
    )

    return df


def metric_safe(x: Any, default: str = "—") -> str:
    if x is None:
        return default
    try:
        if isinstance(x, (int, float)):
            return f"{x:.3f}"
        return str(x)
    except Exception:
        return default


# -----------------------------
# UI
# -----------------------------
st.set_page_config(page_title="SOC Triage Dashboard", layout="wide")

# Quick styling (keeps it “cyber” but readable)
st.markdown(
    """
    <style>
      .block-container { padding-top: 1.2rem; padding-bottom: 2rem; }
      .soc-title { font-size: 2.2rem; font-weight: 800; margin-bottom: 0.1rem; }
      .soc-sub { color: #9aa4b2; margin-top: 0; }
      .glass {
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 14px 16px;
      }
      .pill {
        display:inline-block; padding: 6px 10px; border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.04);
        font-size: 0.85rem; margin-right: 6px;
      }
      .muted { color: #9aa4b2; }
      .small { font-size: 0.9rem; }
    </style>
    """,
    unsafe_allow_html=True,
)

st.markdown('<div class="soc-title">SOC TRIAGE DASHBOARD</div>', unsafe_allow_html=True)
st.markdown('<div class="soc-sub">Human-in-the-loop triage using threshold policy + AI brief.</div>', unsafe_allow_html=True)

# Sidebar: Load data + filters
with st.sidebar:
    st.header("Data Source")

    uploaded = st.file_uploader("Upload triage_output.json", type=["json"])
    if uploaded:
        triage = json.loads(uploaded.read().decode("utf-8"))
        triage_path_used = "Uploaded JSON"
    else:
        triage = load_json(DEFAULT_TRIAGE_JSON)
        triage_path_used = str(DEFAULT_TRIAGE_JSON)

    st.caption(f"Using: {triage_path_used}")

    st.divider()
    st.header("Filters")

    decision_filter = st.multiselect(
        "Decision",
        options=["ESCALATE", "DEPRIORITIZE"],
        default=["ESCALATE", "DEPRIORITIZE"],
    )

    p_min, p_max = st.slider("Probability range", 0.0, 1.0, (0.0, 1.0), 0.01)

    search_text = st.text_input("Search (idx / explanation text)", "")

    st.divider()
    st.header("Export")

    # Report download button (serves an existing PDF file)
    if DEFAULT_REPORT_PDF.exists():
        st.download_button(
            label="Download Report PDF",
            data=DEFAULT_REPORT_PDF.read_bytes(),
            file_name=DEFAULT_REPORT_PDF.name,
            mime="application/pdf",
            use_container_width=True,
        )
    else:
        st.info(
            f"Put your report PDF here:\n`{DEFAULT_REPORT_PDF.name}`\n"
            "Then the download button will appear."
        )


if not triage:
    st.warning(
        "No triage JSON found.\n\n"
        "✅ Fix: generate `triage_output.json` (recommended), or upload it via the sidebar."
    )
    st.stop()


# Header pills
model_name = triage.get("model", "—")
mode_name = triage.get("mode", "—")
cost_model = triage.get("cost_model") or {}
c_fp = cost_model.get("C_FP", "—")
c_fn = cost_model.get("C_FN", "—")

st.markdown(
    f"""
    <div>
      <span class="pill"><b>Model</b>: {model_name}</span>
      <span class="pill"><b>Mode</b>: {mode_name}</span>
      <span class="pill"><b>C_FP</b>: {c_fp}</span>
      <span class="pill"><b>C_FN</b>: {c_fn}</span>
    </div>
    """,
    unsafe_allow_html=True,
)

# KPIs
threshold = triage.get("threshold")
baseline_cost = triage.get("baseline_cost")
optimized_cost = triage.get("optimized_cost")
cost_reduction = triage.get("cost_reduction")

stats = triage.get("metrics_at_threshold") or {}

k1, k2, k3, k4, k5 = st.columns(5)
k1.metric("Threshold (t*)", metric_safe(threshold))
k2.metric("Cost reduction", f"{(float(cost_reduction)*100):.2f}%" if cost_reduction is not None else "—")
k3.metric("Precision", metric_safe(stats.get("precision")))
k4.metric("Recall", metric_safe(stats.get("recall")))
k5.metric("FPR", metric_safe(stats.get("fpr")))

# Main layout: Queue (left) + Details (right)
left, right = st.columns([1.35, 0.85], gap="large")

df = to_alert_df(triage)

with left:
    st.markdown("### Alert Queue")
    st.caption("Ranked by risk probability (p). Filter and then click an alert to view details.")

    if df.empty:
        st.info("No alerts found in JSON under `top_alerts`.")
    else:
        # Apply filters
        view = df.copy()
        view = view[view["decision"].isin(decision_filter)]
        view = view[(view["p"] >= p_min) & (view["p"] <= p_max)]

        if search_text.strip():
            s = search_text.strip().lower()
            # search idx or explanation
            mask = False
            if "idx" in view.columns:
                mask = mask | view["idx"].astype(str).str.contains(s, na=False)
            if "explanation" in view.columns:
                mask = mask | view["explanation"].astype(str).str.lower().str.contains(s, na=False)
            view = view[mask]

        # Risk distribution chart (like the mock)
        st.markdown("#### Risk Distribution")
        if "risk_bucket" in view.columns:
            bucket_counts = view["risk_bucket"].value_counts().reindex(["Critical", "High", "Medium", "Low"]).fillna(0)
            st.bar_chart(bucket_counts)

        st.markdown("#### Queue Table")
        show_cols = [c for c in ["idx", "p", "decision", "risk_bucket"] if c in view.columns]
        st.dataframe(
            view[show_cols].sort_values("p", ascending=False).reset_index(drop=True),
            use_container_width=True,
            height=380,
        )

        # Selection widget (simple + reliable)
        st.markdown("#### Select an alert to view details")
        options = view.sort_values("p", ascending=False)["idx"].dropna().astype(int).tolist()
        selected_idx = st.selectbox("Alert ID (idx)", options=options, index=0 if options else None)

with right:
    st.markdown("### Alert Details")

    if df.empty:
        st.info("No alert details available.")
    else:
        row = df[df["idx"].astype("Int64") == int(selected_idx)].iloc[0]

        st.markdown('<div class="glass">', unsafe_allow_html=True)
        st.markdown(f"**Alert idx:** `{int(row['idx'])}`")
        st.markdown(f"**Probability (p):** `{float(row['p']):.3f}`")
        st.markdown(f"**Decision:** `{row.get('decision', '')}`")
        st.markdown("</div>", unsafe_allow_html=True)

        st.markdown("#### Explanation")
        st.write(row.get("explanation", "—"))

        st.markdown("#### Suggested Actions")
        actions = row.get("suggested_actions", [])
        if isinstance(actions, list) and actions:
            for a in actions:
                st.write(f"- {a}")
        else:
            st.write("—")

    st.divider()
    st.markdown("### AI Brief (Queue Summary)")
    llm_brief = triage.get("llm_brief") or triage.get("agentic_brief") or ""
    if llm_brief:
        st.write(llm_brief)
    else:
        st.info(
            "No AI brief found in JSON.\n\n"
            "If your agent prints the LLM brief, consider also saving it into the JSON under `llm_brief`."
        )

# Footer / safety note
st.caption(
    "Note: Model decisions are computed deterministically from threshold policy. "
    "LLM output (if present) is advisory and should be validated with logs/context."
)
